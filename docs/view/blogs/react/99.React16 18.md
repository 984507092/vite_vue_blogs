# React16 18

### 初始react

#### 安装项目

pnpm create react-app code

#### JSX

React.createElement的语法糖

```jsx
JSX的注意事项
         1. JSX不是字符串，不要加引号
         2. JSX中html标签应该小写，React组件应该大写开头
         3. JSX中有且只有一个根标签
         4. JSX的标签必须正确结束（自结束标签必须写/）
         5. 在JSX中可以使用{}嵌入表达式
                - 有值的语句的就是表达式
         6. 如果表达式是空值、布尔值、undefined，将不会显示
         7. 在JSX中，属性可以直接在标签中设置
             注意：
                 class需要使用className代替
                 style中必须使用对象设置
                     style={{background:'red'}}
                     
 例如
 
 <script type="text/babel">
    const root=ReactDOM.createRoot(document.querySelector("#root"))
    const render=()=>{
    return  root.render((
            <>
            <h3>修改</h3>
            <h4>{title}</h4>
            <button onClick={hangleChange}>change</button>
            </>
        ))
        }
    let title='hello word'
    const hangleChange=()=>{
    title='hello react'
        render()
    }

render()
</script>
```

#### React.createElement

创建虚拟dom

```jsx
const children = [
  React.createElement('p', null, 'Paragraph 1'),
  React.createElement('p', null, 'Paragraph 2'),
  React.createElement('p', {className: 'highlight'}, 'Highlighted Paragraph')
];

const element = React.createElement(
  'div',  // 元素类型
  null,  // 属性对象为空，class id....
  children  // 子元素数组
);
```

#### 虚拟dom diff算法

1. **同级元素对比**：当 Diff 算法对比两个同级的元素列表时，它会尝试找到最少的 DOM 操作来更新列表。这包括添加、删除或移动元素。
2. **元素类型和 Key**：React 通过元素的类型和 `key` 属性来识别不同的元素。如果两个元素的类型和 `key` 都相同，则被认为是相同的元素。
3. **子节点对比**：React 会对比子节点，但主要是在相同类型的元素之间进行。如果子节点是不同类型，React 通常会选择删除旧节点并创建新节点。

<img src="/public/react/2024-10-30-01.png">

#### TSX

```tsx
import React, { memo } from 'react'

const App = memo(() => {
  const click =<T,> (val:T) => {
    console.log(val)
  }
  const id= '123'
  const className = 'class'
  const style={color: 'pink',fontSize: '40px'}
  return (
    <>
    <div onClick={()=>click('hello')} id={id} className={`${className} active`} style={style}>
      点击我
    </div>
    </>
  )
})

export default App
            
            
{/*ts类型约束props*/}
import React, { FC, memo, ReactNode } from 'react'
interface PropsInterface{
  children?:ReactNode,
  name?:string
}
const Index:FC<PropsInterface>= memo((props) => {
  return (
    <>
   
    </>
  )
})
Index.defaultProps={
  name:'默认值'
}
export default Index
```

## 组件化

##### 一、类组件

###### 基本信息

组件名称须首字母大写

需继承React.Component

必须实现render方法

```jsx
快捷键生成类组件模板 rce   
class App extends React.Component{//必须继承 React.Component
            constructor(){
                super()
                this.state={ //数据挂载在state中
                    message:'hello react'
                }
                this.btnChange=this.btnChange.bind(this)//保证this不丢失
            }
            btnChange(){
                console.log(this);//类中属于严格模式，this指向undefined，构造函数使用bind改变this
                this.setState({message:"react"})
            }
            render(){
                return <>
                        <h3>{this.state.message}</h3>
                        <button onClick={this.btnChange}>修改</button>
                        </>
            }
        }
        const root=ReactDOM.createRoot(document.querySelector('#root'))
        root.render(<App/>)

例子：
  class App extends React.Component{
            constructor(){
                super()
                this.state={
                    moviceList:['星际探险','流浪地球','天空漫步','大话西游']
                    }
                }
             getList(){
                  const list=  this.state.moviceList.map((item,index)=>{
                        return <li key={index}>{item}</li>
                    })
                    return list
                }
            render(){
                return(
                    <>
                    <h3>电影列表</h3>
                    {this.getList()}
                    </>
                )
            }
        }
```

###### render函数

<img src="/public/react/2024-10-30-04.png">

###### 类组件生命周期

```jsx
constructor() --构造函数，组件实例创建时调用
render() --渲染方法，是类组件中唯一必须实现的方法。当组件需要重新渲染时，React 会调用这个方法
componentDidMount() --挂载后调用
componentDidUpdate(prevProps,prevState,snapshort) --更新后调用
componentWillUnmount() --卸载后调用

不常用的生命周期
  shouldComponentUpdate(){
    //控制更新，需不需要重新渲染组件
    if(this.state.num %2===0){
        console.log('触发渲染');
        return true
    }else{
        console.log('不渲染');
        return false
    }
  }

  getSnapshotBeforeUpdate(){
    //更新后在render调用后，componentDidUpdate调用前触发，用于保存数据
    return{/返回的数据在componentDidUpdate的第三个参数可以拿到
        name:'xxm'
    }
  }
```

<img src="/public/react/2024-10-30-02.png">

###### 类组件通信

###### 父传子

```jsx
 App.jsx
   this.state={
            banner:['banner1','banner2','banner3']
        }
  <Banner list={this.state.banner}></Banner>
 
Banner子组件，通过props接收
export class Banner extends React.Component {
    constructor(props){
        super(props)
    }
  render() {
    return (
      <>
      {this.props.list.map((item)=>{
        return <h3 key={item}>{item}</h3>
      })}
      </>
    )
  }
}
```

1-使用propTypes对父传子参数进行类型校验

```jsx
import propType from 'prop-types'

Banner.propType={
    list:propType.array.isRequired,//限制传递数组且必传
    title:propType.string
}
//设置默认值
1.
Banner.defaultProps={
  list:[],
  title:'默认标题'
}
2.
export class Banner extends React.Component {
    constructor(props){
        super(props)
    }
    static defaultProps={
      list:[],
      title:"一个默认标题"
    }
}
```

2-父传子传递格式为**对象**

```jsx
   this.state={
            info:{name:'xxm',age:19,location:'汕头'}
        }
  <Banner {...this.state.info}></Banner>
//子组件通过this.props访问info的属性内容
```

###### 子传父

```jsx
//App.jsx
changeTitle(val){
        this.setState({
            title:val
        })
    }

<Banner changeClick={(val)=>{this.changeTitle(val)}}></Banner>

//Banner.jsx
hangelClick(){
      this.props.changeClick('hello react')
    }

<button onClick={()=>{this.hangelClick()}}>click</button>


```

###### 类组件插槽

```jsx
1.第一种，使用children
//App.jsx
import React, { Component } from 'react'
import { Slot } from './components/Slot'
export class SlotApp extends Component {
  render() {
    return (
    <>
    <Slot>
        <button>返回按钮</button>
        <h3>标题</h3>
        <button>home按钮</button>
    </Slot>
    </>
    )
  }
}

//Slot.jsx
import React, { Component } from 'react'
import '../components/Slot.css'
export class Slot extends Component {
  render() {
    console.log(this.props.children);//插入的东西传到props.children里,多个元素会放在数组里
    return (
  <>
  <div className="nav">
  <div className="left">
        {this.props.children[0]}
   </div>
    <div className="center">
    {this.props.children[1]}
    </div>
    <div className="reight">
    {this.props.children[2]}
    </div>
    </div>
    </>
    )
  }
}



2.第二种，使用props
//App.jsx
import React, { Component } from 'react'
import { Slot } from './components/Slot'
export class SlotApp extends Component {
  render() {
    return (
    <>
    <Slot
    left={ <button>返回按钮</button>}
    center={<h3>标题</h3>}
    right={<button>home按钮</button>}
    >
    </Slot>
    </>
    )
  }
}
//Solt.jsx
import React, { Component } from 'react'
import '../components/Slot.css'
export class Slot extends Component {
  render() {
    console.log(this.props);
    return (
   <>
    <div className="nav">
     <div className="left">
     {this.props.left}
     </div>
     <div className="center">
     {this.props.center}
     </div>
     <div className="reight">
     {this.props.right}
     </div>
     </div>
    </>
    )
  }
}
```

###### 作用域插槽

```jsx
//App.jsx 
import React, { Component } from 'react'
import { Slot } from './components/Slot'
export class SlotApp extends Component {
    getTabItem(item){
        if(item==='back'){
            return <button>{'<'}</button>
        }else{
            return <button>{'home'}</button>
        }
    }
  render() {
    return (
    <>
    <Slot
  itemButton={item=>this.getTabItem(item)}//传递一个函数给子组件，子组件回调函数传参，调用getTabItem格式组件
   center={<h3>标题</h3>}
    >
    </Slot>
    </>
    )
  }


//Slot
import React, { Component } from 'react'
import '../components/Slot.css'
export class Slot extends Component {
  render() {
    console.log(this.props);
    return (
   <>
   <div className="nav">
    <div className="left">
     {this.props.itemButton('back')}
     </div>
     <div className="center">
     {this.props.center}
     </div>
     <div className="reight">
     {this.props.itemButton('home')}
     </div>
     </div>
    </>
    )
  }
}
```

###### context

一个公共的存储空间，类似provide

```jsx
1.创建共享空间
//itemContext.js
import React from "react"
const itemContext=React.createContext({
   item:['a','b','c']//默认内容，非itemContext子组件，可以通过设置contextType，访问默认值
})
export default itemContext

2.设置共享内容
 <itemContext.Provider value={{name:"xxm"}}>
    <slotContext.Provider value={{color:'pink'}}>
   <Slot
    itemButton={item=>this.getTabItem(item)}
    center={<h3>标题</h3>}
    >
    </Slot>
   </slotContext.Provider>
    </itemContext.Provider>
3.后代使用
//设置组件的contextType为需要的共享库
 Slot.contextType=slotContext
//直接使用this.context访问到共享对象
<h3>{this.context.color}</h3>//拿到pink

4.使用多个共享空间，只能设置一个contextType，如需使用多个共享空间，通过
//App.jsx
 <itemContext.Provider value={{name:"xxm"}}>
    <slotContext.Provider value={{color:'pink'}}>
   <Slot  
    itemButton={item=>this.getTabItem(item)}
    center={<h3>标题</h3>}
    >
    </Slot>
   </slotContext.Provider>
    </itemContext.Provider>

//solt.jsx
  <itemContext.Consumer>//消费者，通过一个回调函数获取共享值
        {value=>{
            return <h3>{value.name}</h3> 拿到xxm
        }}
  </itemContext.Consumer>
```

###### 事件总线

```jsx
//App.jsx
import React, { Component } from 'react'
import { BusComponents } from './components/BusComponents';
import bus from './untils/bus.ts';
export class Bus extends Component {
  render() {
    return (
      <>
      <BusComponents></BusComponents>
      </>
    )
  }
  componentDidMount(){
    //订阅事件
    bus.on('pre',(val)=>{
        console.log(val)
    })
    bus.on('next',(val)=>{
        console.log(val)
    })
  }
  componentWillUnmount(){
    //销毁监听事件
    bus.off('pre')
    bus.off('next')
  }
}


//子组件
import React, { Component } from 'react'
import bus from './../untils/bus.ts';
export class BusComponents extends Component {
    clickPre(){
        bus.emit('pre','上一个')//触发事件
    }
    clickNext(){
        bus.emit('pre','下一个')//触发事件
    }
  render() {
    return (
      <>
      <button onClick={()=>{this.clickPre()}}>pre</button>
      <button onClick={()=>{this.clickNext()}}>next</button>
      </>
    )
  }
}
```

###### setState

react没有进行数据拦截，更新数据需要通过setState进行重新渲染，setState是异步调用

原理

```jsx
this.state={
message:'hello word',
counter:0    
}

changeMessage(){
    this.setState({
 message:'hello react'
    })
}
通过Object.assign(this.state,newState)合并对象，更新修改的数据，在合适的时机调用render()
```

三种使用方法

```jsx
1.对象形式
changeMessage(){
    this.setState({
 message:'hello react'
    })
}

2.回调函数
    constructor(props){
        super(props)
        this.state={
              message:"xxm"
        }
    }
   hangleChange(){
        this.setState((oldState,props)=>{
            console.log(oldState,props)//获取上一个state数据，和父组件传递的数据
            return{
                message:props.name
            }
        })
    }

3.获取修改的数据，第二个参数传入一个回调函数
    hangleChange(){
        this.setState((oldState,props)=>{
            console.log(this.state.message)//旧的数据，拿到xxm
            return{
                message:props.name
            }
        },()=>{
            这个回调函数会在状态更新并且组件重新渲染完成后被调用
            console.log(this.state.message)//获取修改后的数据，xxm is good
            
        })
    }
```

setState异步更新的好处：

如果每次调用setState都进行更新一次，render会频繁调用，页面重新渲染，最后的办法是获取多个更新，批量更新，调用一次render函数

```jsx
    hangleClick(){
        this.setState((state)=>{
            console.log(state.count);//0
            return {
                count:state.count+1
            }
        })
        this.setState((state)=>{
            console.log(state.count);//1
            return {
                count:state.count+1
            }
        })
        this.setState((state)=>{
            console.log(state.count);//2
            return {
                count:state.count+1
            }
        })
    }
批量处理，调用一次render函数
```

###### 获取dom元素

```jsx
1.字符串//该方法不再被支持
export  class GetDom extends PureComponent {
    constructor(){
        super()
        this.state={
            message:'xxm'
        }
    }
    getDom(){
        console.log(this.refs.h3ref);   //通过this.refs拿到，不过该方法不再被支持
    }
  render() {
    return (
      <>
      <h3 ref='h3ref'>{this.state.message}</h3>//绑定字符串
      <button onClick={()=>{this.getDom()}}>get</button>
      </>
    )
  }
}
 

2.createRef //常用
export  class GetDom extends PureComponent {
    constructor(){
        super()
        this.state={
            message:'xxm'
        }
        this.h3ref=createRef()
    }
    getDom(){
    console.log(this.h3ref.current);//<h3>xxm</h3>
    }
  render() {
    return (
      <>
      <h3 ref={this.h3ref}>{this.state.message}</h3>
      <button onClick={()=>{this.getDom()}}>get</button>
      </>
    )
  }
}

3.回调函数
export  class GetDom extends PureComponent {
    constructor(){
        super()
        this.state={
            message:'xxm'
        }
        this.h3ref=null
    }
    getDom(){
        console.log(this.h3ref);   
    }
  render() {
    return (
      <>
      <h3 ref={(e)=>{this.h3ref=e}}>{this.state.message}</h3>//回调函数，拿到e赋值给h3ref
      <button onClick={()=>{this.getDom()}}>get</button>
      </>
    )
  }
}
```

##### 二、函数组件

###### 基本信息

没有生命周期，没有this指向，没有内部状态state

```jsx
import React from 'react'

export const Hello_fun=()=> {
  return (
    <div>Hello_fun</div>
  )
}
```

##### useState

```jsx
1.值是简单类型
import React, { useState } from 'react'
const HookApp=()=> {
  const [count,setCount]=useState(0)
  const changeCount=(state)=>{
    if(state===1){  
      setCount(count+1)
    }else{
      setCount(count-1)
    }
  }
  return (
    <>
    当前计数：{count}
    <button onClick={()=>changeCount(1)}>+1</button>
    <button onClick={()=>changeCount(-1)}>-1</button>
    </>
  )
}
export default HookApp 

2.值是复杂类型如对象
const[obj,setobj]=useState({name:'kerwin',age:19})
const changeObj=()=>{
setobj({...obj,age:20})//地址发生改变，创建一个新的对象，改变age并覆盖原来的对象
}
```

##### useEffect

```jsx
 1.基本使用
 useEffect(()=>{
    console.log('渲染执行') //组件每次渲染执行
    return ()=>{
      console.log('组件卸载')//组件每次卸载执行，可做处理清理函数
    }
  })

2.监听依赖，依赖改变执行
  2.1
  useEffect(()=>{
    console.log('只执行一次');
  },[])

  2.2
  const [count,setcount]=useState(0)
  useEffect(()=>{
    console.log('count改变执行');
  },[count])
```

##### useContext共享数据

```jsx
1.创建共享空间
import React from "react";
export const userContext=React.createContext()

2.传递共享数据
import React, { memo, useState } from 'react'
import { userContext } from './context/userContext';
import Component from './components/Component';
const HookApp = memo(() => {
  const [userId,setUserId]=useState(0)
  return (
    <>
    <userContext.Provider value={userId}>//共享id
     < Component></Component>
    </userContext.Provider>
    </>
  )
})
export default HookApp

3.子组件通过useContext使用共享数据
import React, { memo, useContext } from 'react'
import { userContext } from '../context/userContext'
const Component = memo(() => {
  const userId=useContext(userContext)
    return (
    <>
    {userId}
    </>
  )
})
export default Component
```

##### useReducer

提供更复杂的方式来处理组件的状态

```jsx
1.定义逻辑处理函数
const countRunder=(state,action)=>{
  switch(action.type){
    case 'increment':
      return {...state,count:state.count+1}
    case 'dercrement':
        return {...state,count:state.count-1}
      default:
        return state
  }
}
2.使用hook创建状态
const[state,dispatch]=useReducer(countRunder,{count:0})

3.使用
  <h3>当前计数{state.count}</h3>
  <button onClick={()=>dispatch({type:'increment'})}>+1</button>
  <button onClick={()=>dispatch({type:'dercrement'})}>-1</button>
```

##### useCallback

缓存一个函数，传递给子组件，如果监听的依赖项没有变化，就返回相同的函数实例，子组件不会重新渲染，提高性能

```jsx
import React, { memo, useCallback} from 'react'
const HookApp = memo(() => {
  const [count,setCount]=useState(0)
const changeCount= useCallback(()=>{
    setCount(count+1)
  },[count])
  return (
    <>
    <h3>{count}</h3>
    <button onClick={changeCount}>change</button>
    </>
  )
})
export default HookApp
```

##### useMemo

```tsx
1.缓存返回结果，监听依赖，依赖改变重新计算，类似计算属性
import React, { memo, useMemo, useState } from 'react'
const UseMemoApp = memo(() => {
    const [count,setCount]=useState(0)
    const a=1
    const b=2
    const compont=useMemo(()=>{
        console.log('执行了');
        return a+b
    },[a,b])
  return (
    <>
    <h3>当前计数{compont}</h3>
    <h4>{count}</h4>
    <button onClick={()=>setCount(count+1)}>+1</button>//点击按钮，compont依赖不变，结果不会重新计算
    </>
  )
})
export default UseMemoApp

2.传递给子组件是对象形式，使用useMemo进行性能优化，对象内容不改变，子组件不渲染
import React, { memo, useMemo, useState } from 'react'
import Component from './components/Component';
const UseMemoApp = memo(() => {
    const [count,setCount]=useState(0)
    const info=useMemo(()=>({name:"John",age:20}),[])
  return (
    <>
    <Component info={info}> </Component>
    {count}
    <button onClick={()=>setCount(count+1)}>Click</button>
    </>
  )
})

export default UseMemoApp
```

##### useRef

```jsx
1.获取dom
import React, { memo, useRef } from 'react'

const UseRefApp = memo(() => {
  const inputRef=useRef()
  return (
    <>
    <input type="text" ref={inputRef} />
    <button onClick={() => inputRef.current.focus()}>focus</button>
    </>
  )
})

export default UseRefApp
2.解决闭包陷进
import React, { memo, useCallback, useRef, useState } from 'react'
const UseRefApp = memo(() => {
  const inputRef=useRef()//保存值是同一个对象
  const[count,setCount]=useState(0)
  inputRef.current=count
  const change=useCallback( ()=> {
    setCount(  inputRef.current+1)
  },[])
  return (
    <>
    {count}
    <button onClick={change}>+</button>
    </>
  )
})

export default UseRefApp
```

##### useImperativeHandle

向外暴露属性方法

```jsx
import React, { forwardRef, memo, useImperativeHandle, useRef } from 'react'
 //子组件
 const Component = memo(forwardRef((props,ref)=>{
  const inpRef=useRef()
  useImperativeHandle(ref,()=>{//向外暴露方法
    return{
      focus(){
        inpRef.current.focus()
      }
    }
  })
    return (
      <>
      <input type="text" ref={inpRef} />
      </>
    )
 }))
 
 //父组件
const UseImperativeHandle = memo(() => {
  const comRef=useRef()
  const watch=()=>{
    comRef.current.focus()
  }
  return (
    <>
      <Component ref={comRef}></Component>
      <button onClick={watch}>watch</button>
    </>
  )
})

export default UseImperativeHandle
```

##### useLayoutEffect

在dom更新后，浏览器渲染前执行回调，会阻塞代码

```jsx
import React, { useLayoutEffect, useState } from 'react';

function PositionReporter() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useLayoutEffect(() => {
    const element = document.getElementById('position-reporter');
    const rect = element.getBoundingClientRect();
    setPosition({ x: rect.left, y: rect.top });
  }, []); // 空依赖数组意味着这个 effect 只在组件挂载时运行一次

  return (
    <>
      Position: ({position.x}, {position.y})
    </>
  );
}
```

##### 自定义Hook

```jsx
1.监听组件创建销毁Hook
import React, { memo, useEffect } from 'react'
//自定义hook use开头
const useLogLive=(cName)=>{
    useEffect(()=>{
        console.log(cName+'组件挂载');
        return ()=>{
            console.log(cName+'组件卸载');
            
        }
    })
}


2.监听组件滚动位置Hook
import {useEffect, useState} from 'react'
const useScroll=()=>{
    const [scrollX, setScrollX] = useState(0);
    const [scrollY, setScrollY] = useState(0);
    useEffect(()=>{
        const handleScroll=()=>{
            setScrollX(window.scrollX)
            setScrollY(window.scrollY)
        }
        window.addEventListener('scroll',handleScroll)
        return()=>{
        window.removeEventListener('scroll',handleScroll)
        }
    },[])
    return [scrollX,scrollY]
}
export default useScroll

3.本地存储
import { useEffect, useState } from "react"

const useLocalhost=(key)=>{
    const [data,setData]=useState(()=>{
        const data=localStorage.getItem(key)
        if(!data)return ''
        return JSON.parse(data)
    })
    useEffect(()=>{
        localStorage.setItem(key,JSON.stringify(data))
    },[data])
    return [data,setData]
}
export default useLocalhost


使用
import React, { memo, useEffect, useState } from 'react'
import './hookStyle.css'
import useScroll from './hook/useScroll';
import useLocalhost from './hook/useLocalhost';
const DiyHookApp = memo(() => {
    useLogLive('DiyHookApp')
  const[scrollX,scrollY]=  useScroll()
  const[name,setName]=  useLocalhost('name')
  return (
    <>
  <div className='hook'>
  <h3>x:{scrollX}</h3>
  <h3>y:{scrollY}</h3>
  <hr />
  <h3>name:{name}</h3>
  <button onClick={()=>{setName('张三')}}>set</button>
  </div>

    </>
  )
})

export default DiyHookApp
```

## react进阶

#### 添加代码片段

```tsx
import React, { memo } from 'react'
const App = memo(() => {
  const html="<h3>helloWord</h3> "
  return (
    <>
   <div dangerouslySetInnerHTML={{__html: html}}></div>
    </>
  )
})

export default App
```

#### react事件绑定

类组件 事件绑定，传值

```jsx
三种解决this问题
  class App extends React.Component{
        constructor(){
            super()
            this.state={
                num:100
            }
        }
     //1 显式绑定this
        click1(name,age,event){
            console.log(this);
        }
       //2 es6 calss fields类属性
        click2=()=>{
            console.log(this);
        }
        //3 箭头函数
        click3(event,name,age){
            console.log(this); 
        }
        render(){
            return(
                <>
                <button onClick={this.click1.bind(this,'xxm',19)}>按钮1</button>//显式绑定this
                <button onClick={this.click2}>按钮2</button>//es6 calss fields
                <button onClick={(e)=>this.click3(e,'xxm',18)}>按钮3</button>//箭头函数
                </>
            )
        }
    }

例子：
   class App extends React.Component{
        constructor(){
            super()
            this.state={
                moviceList:['星际探险','流浪地球','天空漫步','大话西游'],
                selectIndex:0
            }
        }
        changeIndex(index){
            this.setState({
                selectIndex:index
            })
        }
        render(){

            return(
                <>
                {this.state.moviceList.map((item,index)=>{
                    return (
                        <>
                        <li 
                        className={this.state.selectIndex==index? 'active':''}
                        onClick={()=>{this.changeIndex(index)}}
                        >{item}</li>
                        </>
                    )
                })}
                </>
            )
        }
    }
    const root=ReactDOM.createRoot(document.querySelector('#root'))
    root.render(<App/>)
```

函数组件 事件绑定，传值

```jsx
import React, { useState } from 'react'

const HookApp=()=> {
  const [count,setCount]=useState(0)
  const changeCount=(state)=>{
    if(state===1){
      setCount(count+1)
    }else{
      setCount(count-1)
    }
  }
  return (
    <>
    当前计数：{count}
    <button onClick={()=>changeCount(1)}>+1</button>
    <button onClick={()=>changeCount(-1)}>-1</button>
    </>
    
  )
}
export default HookApp 
```

#### 条件渲染

```jsx
  class App extends React.Component{
            constructor(){
                super()
                this.state={
                    isReady:false,
                    friend:undefined
                }
            }
            ready(){
                this.setState({
                    isReady:true,
                    friend:{name:'xxm'}
                })
            }
            unready(){
                this.setState({
                    isReady:false,
                    friend:undefined
                })
            }
            render(){
                const {friend}=this.state
                    let showElement=null
                    //if判断
                    if(this.state.isReady){
                        showElement=<h3>开始战斗</h3>
                    }else{
                        showElement=<h3>请准备</h3>

                    }
                return(
                    <>
                    {showElement}
          //三目运算符
                    {this.state.isReady? <button onClick={()=>{this.unready()}}>取消准备</button>:
                      <button onClick={()=>{this.ready()}}>准备</button>}
     //逻辑与
                    {friend && <h3>{friend.name+'加入战斗'}</h3>}
                    </>
                )
            }
        }
```

#### 列表渲染

```jsx
 class App extends React.Component{
        constructor(){
            super()
            this.state={
            datalist:[
                {name:'xxm1',age:19,score:99},
                {name:'xxm2',age:20,score:79},
                {name:'xxm3',age:18,score:93},
                {name:'xxm4',age:17,score:90},
                {name:'xxm5',age:19,score:82}
            ]
            }
        }
        render(){
            let {datalist}=this.state
            return(
                <>
                {
                 datalist.filter(item=>item.age>=18).slice(0,4).map((item,index)=>{
                        return (
                    < div key={index}>
                    <h3>姓名：{item.name}</h3>
                    <h4>年龄：{item.age}</h4> 
                    <h5>成绩：{item.score}</h5> 
                    </div>
                        )
                    })
                }    
                </>

            )
        }
    }
    const root=ReactDOM.createRoot(document.querySelector('#root'))
    root.render(<App/>)
```

#### React过渡动画

###### react-transition-group

react-transition-group主要包含四个组件:

Transition 该组件是一个和平台无关的组件(不一定要结合CSS)

CSSTransition 实现CSS过渡和动画的组件

SwitchTransition两个组件显示和隐藏切换时，使用该组件

TransitionGroup将多个动画组件包裹在其中，一般用于列表中元素的动画

<!-- ![](D:\Users\ZhuZh\Desktop\react\image\动画类名.png) -->

###### CSSTransition

```jsx

    <CSSTransition // 使用 CSSTransition 组件来包裹内容
          in={isShow} // in 属性控制是否显示
          unmountOnExit={true} // 当不显示时卸载组件
          timeout={2000} // 设置动画时长
          classNames="xxm" // 指定动画的类名
          onEnter={console.log('开始进入动画')} // 进入动画开始时的回调
          onEntering={console.log('正在执行进入动画')} // 进入动画执行中的回调
          onExited={console.log('结束进入动画')} // 进入动画结束的回调
          onExit={console.log('开始结束动画')} // 结束动画开始的回调
          onExiting={console.log('正在进行结束动画')} // 结束动画执行中的回调
          onEntered={console.log('结束结束动画')} // 结束动画结束的回调
          appear // 使初次挂载也有动画效果
          nodeRef={this.nodeRef} // 将创建的 ref 传给 CSSTransition
        >
          <h1 ref={this.nodeRef}>测试内容</h1> 
   </CSSTransition>

//css
/* 第一次入场动画 */
.xxm-appear{
    transform: translateX(-200px);
}
.xxm-appear-active{
    transform: translateX(0px);
    transition: all 2s ease;
}
/* 入场动画 */
.xxm-enter{
    opacity: 0;
}
.xxm-enter-active{
    opacity: 1;
    transition: all 2s ease;
}
/* 离场动画 */
.xxm-exit{
    opacity: 1;
}
.xxm-exit-active{
    opacity: 0;
    transition: all 2s ease;
}

```

###### SwitchTransition

```jsx
     <SwitchTransition mode='out-in' >
        {/* 先离开后进入*/}
        <CSSTransition key={isLogin ? 'exit' :'login' } //根据key值切换，进行动画渲染
            classNames='xxm' 
            timeout={500} 
            nodeRef={this.SwitchRef}>
        <button onClick={e=>this.setState({isLogin:!isLogin})} ref={this.SwitchRef}>
            {isLogin ?'退出' : '登录'}
          
        </button>
        </CSSTransition>
      </SwitchTransition>

//css
.xxm-enter{
    transform: translateX(-100px);
    opacity: 0;
}
.xxm-enter-active{
    transform: translateX(0px);
    opacity: 1;
    transition: all 0.5s ease;
}
.xxm-exit{
    transform: translateX(0px);
    opacity: 1;
}
.xxm-exit-active{
    transform: translateX(100px);
    opacity: 0;
    transition: all 0.5s ease;
}
```

###### TransitionGroup

渲染列表动画

```jsx
      <TransitionGroup component="ul">
          {books.map((item,index) => {
            return (
              <CSSTransition
                key={item.id}//根据id，渲染动画
                classNames="xxm"
                timeout={500}
              >
                <li ref={this.liRef}>
                  <span>{item.name} -- {item.price}</span>
                  <button onClick={() => this.delBook(index)}>del</button>
                </li>
              </CSSTransition>
            );
          })}
        </TransitionGroup>

//css
.xxm-enter{
    transform: translateX(-100px);
    opacity: 0;
}
.xxm-enter-active{
    transform: translateX(0px);
    opacity: 1;
    transition: all 0.5s ease;
}
.xxm-exit{
    transform: translateX(0px);
    opacity: 1;
}
.xxm-exit-active{
    transform: translateX(100px);
    opacity: 0;
    transition: all 0.5s ease;
}
```

#### 性能优化

```jsx
组件
1.scu 使用 shouldComponentUpdate
  shouldComponentUpdate(newProps,newState){
    if(this.props.message !==newProps.message){
        return true//重新渲染
    }
    return false//不渲染
  }

2.继承PureComponent，内部使用shouldComponentUpdate自动优化，但是只会比较浅层
export class Scu extends PureComponent {}


函数组件 使用memo
export const ScuFun= memo(
    function ScuFun(props) {
        console.log('ScuFun')
      return (
        <>
        <h3>{props.count}</h3>
        </>
      )
    }
)

```

#### 获取组件实例

```jsx
1.类组件
使用createRef()

export  class GetDom extends PureComponent {
    constructor(){
        super()
        this.state={
            message:'xxm'
        }
        this.classRef=createRef()//创建ref
    }

    changGetClassShow(){
    this.classRef.current.changeIsshow()//通过子组件实例使用子组件的方法
    }
  render() {
    return (
      <>
      <GetClass ref={this.classRef}></GetClass>//获取子组件实例
      <button onClick={()=>{this.changGetClassShow()}}>change</button>
      </>
    )
  }
}


2.函数组件，使用useRef获取函数组件  forwardRef useImperativeHandle高阶函数，获取向外暴露属性
//父组件
function App() {
  const getFunRef = useRef();
  const handleToggle = () => {
    getFunRef.current.toggleVisibility();//调用函数组件的方法
  }
  return (
    <div>
      <GetFun ref={getFunRef} />
      <button onClick={handleToggle}>Toggle Visibility</button>
    </div>
  );
}

//子组件
import React, { useState, useImperativeHandle, forwardRef } from 'react';
export const GetFun = forwardRef((props, ref) => {
  const [isVisible, setIsVisible] = useState(true);
  useImperativeHandle(ref, () => ({
    toggleVisibility() {
      setIsVisible(!isVisible);
    }
  }));

  return (
    <>
      {isVisible && <h3>helloword</h3>}
    </>
  );
});
```

#### 受控组件和非受控组件

受控组件

在 React 中，受控组件是指那些由 React 状态（state）完全控制的表单组件。在受控组件中，表单数据的状态（如输入框的值、复选框的选中状态等）由组件的状态来管理，并且所有的表单操作都会通过 React 的状态更新机制来进行。

```jsx
多选checkbox，select
import React, { PureComponent } from 'react'
export class Form extends PureComponent {
    constructor(){
        super()
        this.state={
            hobbyList:[
                {isChecked:false,id:'sing',text:'唱歌'},
                {isChecked:false,id:'dance',text:'跳舞'},
                {isChecked:false,id:'rap',text:'说唱'}
            ],
            technology:['react']
        }
    }
    hangleChange(e,index){
        let newHobbyList=[...this.state.hobbyList]
        newHobbyList[index].isChecked=!this.state.hobbyList[index].isChecked
        this.setState({
            hobbyList:newHobbyList
        })
    }
    hangleSlect(e){
     const options=Array.from(e.target.selectedOptions,item=>item.value)//包装成数组
        this.setState({
            technology:options
        })
    }
    send(){
        let data=this.state.hobbyList.filter((item)=>item.isChecked===true).map((item)=>item.text)
        alert(data)
    }
  render() {
    return (
      <>
      <h3>你的兴趣爱好</h3>
     {
        this.state.hobbyList.map((item,index)=>{
            return (
                <label htmlFor={item.id} key={item.id}>
      <input type="checkbox" 
                    id={item.id}
                    checked={item.isChecked} 
                    onChange={(e)=>{this.hangleChange(e,index)}}
                    />{item.text}
                </label>
            )
        })
     }
     <h3>你喜欢的技术</h3>
     <select value={this.state.technology} onChange={(e)=>{this.hangleSlect(e)}} multiple>//multiple多选
        <option value="vue">Vue</option>
        <option value="react">React</option>
        <option value="uniapp">uniapp</option>
     </select>
     <hr />
     <button onClick={()=>{this.send()}}>提交</button>
      </>
    )
  }
} 
```

非受控组件

通过defaultValue设置默认值，通过ref借助dom获取值

```jsx
export class Form extends PureComponent {
    constructor(){
        super()
        this.inpRef=createRef()//获取dom
    }
render(){
    return(
     <input type="text" defaultValue={'hello word'}  ref={this.inpRef}/>
    )
}
获取值： this.inpRef.current.value
```

#### 高阶组件HOC

React 高阶组件（Higher-Order Components，简称 HOC）是一种基于React组合特性的高级技术。HOC 是一种函数，它接受一个组件并返回一个新的组件

类组件

```jsx
//App.jsx
import React, { PureComponent } from 'react'
import EnhanceConext from './untils/enhanceContext'
import Them from './components/Them'

export class EnhanceComponents extends PureComponent {
  render() {
    return (
      <>
      <EnhanceConext.Provider value={{name:'xxm'}}>
        <Them></Them>
      </EnhanceConext.Provider>
      </>
    )
  }
}

//高阶组件
import React from 'react'
import EnhanceConext from './enhanceContext'
export const enhance=(NewComponets)=> {
  return(props)=>{//返回一个函数组件
    return(
        <EnhanceConext.Consumer>
        {
          value=>{
            return <NewComponets {...value} {...props}></NewComponets>
              //将共享厂库的值通过父传子传递给参数组件
          }  
        }
        </EnhanceConext.Consumer>
    )
}
}
export default enhance

//子组件
import React, { PureComponent } from 'react'
import enhance from '../untils/enhance'
 class Them extends PureComponent {
  render() {
    return (
      <>
      <h3>{this.props.name}</h3>//使用高阶组件传递的值
      </>
    )
  }
}

export default enhance(Them)//使用高阶组件包装原组件
```

函数组件

```jsx
//App.jsx
import React from 'react'
import AuthComponents from './components/AuthComponents'

export const Auth=(props)=> {
  const Login=()=>{
    localStorage.setItem('token','xxm')
  }
  return (
    <>
    <AuthComponents></AuthComponents>
    <button onClick={Login}>登录</button>
    </>
  )
}

//高阶组件
import React from 'react'
export const AuthHoc=(NewComponents)=> {
    let isLogin=localStorage.getItem('token')
    return (props)=>{
        //根据状态渲染不同内容
        if(isLogin){
            return <NewComponents></NewComponents>
        }else{
            return <h3>鉴权失败，请先登录</h3>
        }
    }
}

//子组件
import React from 'react'
import { AuthHoc } from '../untils/AuthHoc'
 const AuthComponents=()=> {
  return (
    <>
    <h3>hello word</h3>
    </>
  )
}
export default AuthHoc(AuthComponents)//使用高阶组件包装原组件
```

#### Portals传送门

类组件

```jsx
import React, { PureComponent } from 'react'
import {createPortal} from 'react-dom'
export class PortalsComponents extends PureComj]63nent {
  render() {
      {*/接收俩个参数 传递的内容 位置/*}
    return createPortal(this.props.children,document.querySelector('#modal'))
  }
}
```

函数组件

#### Fragment

在React中，`Fragment` 是一种用于将多个子组件分组，而不需要向DOM中添加额外节点的方式

```jsx
1.使用短语法 <></>
function List({ items }) {
  return (
    <>
      {items.map(item => (
        <li key={item.id}>{item.text}</li>
      ))}
    </>
  );
}

2.需要绑定key，使用完整写法Fragment
import React from 'react';
function List({ items }) {
  return (
    <Fragment>
      {items.map(item => (
        <Fragment key={item.id}>
          <li>{item.text}</li>
        </Fragment>
      ))}
    </Fragment>
  )
}
```

#### StrictMode严格模式

在React中，"严格模式"（StrictMode）是一个用于检测应用程序中潜在问题的工具。`<StrictMode>` 组件在开发模式下启用多种检查和警告，1.识别不安全的生命周期 2.识别过时的api 3.检擦意外副作用

```jsx
import React from 'react';

function App() {
  return (
    <StrictMode>  
      <>
        <MyComponent /> MyComponent组件开启严格模式
      </>
    </StrictMode>
  );
}
```

## react如何编写CSS

#### classModule

文件名：xxx.module.css

```jsx
//CssApp.module.css
.title {
  color: pink;
}

使用：
import React, { PureComponent } from 'react'
import Appstyle from '../src/css/CssApp.module.css'//引入
export class CssApp extends PureComponent {
  render() {
    return (
      <>
      <h3 className={Appstyle.title}>我是标题</h3>//使用
      </>
    )
  }
}

```

#### Css in js

使用库：styled-components

```jsx
1.基本使用
style.js
import styled from 'styled-components'
export const Appwrapper=styled.div`
.title{
   color: green;
}
`
export const Headerwrapper=styled.div`//头部
 .title{
    color: pink;
 }
 .content{
    border: 1px solid pink;
    width: 100px;
    height: 100px;
    line-height: 100px;
    text-align: center;
 }
`
export const Flootwrapper=styled.div`//底部
.text{
   font-size: 24px;
   color: pink;
}
`


App.jsx
import React, { PureComponent } from 'react'
import { Appwrapper,Headerwrapper,Flootwrapper } from './css/style.js'
export class CssApp extends PureComponent {
  render() {
    return (
      <>
       <Appwrapper>
      <h3 className='title'>我是标题</h3>
      <Headerwrapper>
        <h3 className='title'>css in js </h3>
        <div className='content'>
            hello word
        </div>
        </Headerwrapper>
      <Flootwrapper>
      <p className='text'>免责声明</p>
      <p className='text'>版权声明</p>
      </Flootwrapper>
      </Appwrapper>
      </>
    )
  }
}


2.使用js变量

2-1
通过回调接收到外部传递的props
<Flootwrapper size={size} color={color}>
      <p className='text'>免责声明</p>
      <p className='text'>版权声明</p>
 </Flootwrapper>

//接收外部props
export const Flootwrapper=styled.div`
.text{
   font-size: ${props=>props.size}px;
   color: ${props=>props.color};
}
`

2-2 使用外部统一主题变量
定义一个js主题文件
theme.js
export const smallSize='12px'
export const middleSize='16px'
export const largeSize='20px'
export const primaryColor='#ff8800'


style.js
import * as theme from '../../src/style/them.js'
使用：
export const Appwrapper=styled.div`
.title{
   color: ${theme.primaryColor};//使用变量
}
`

3.设置默认值
export const Contentwrapper=styled.div.attrs(props=>{
   return{
      ContentColor:props.color || 'orange'
   }
})`
.title{
   color: ${props=>props.ContentColor};
}
`

4.继承
const { button } = styled;
export const XxmButton=button`
border: 10px;
`
export const XxmWarnButton=styled(XxmButton)`
background-color: pink;
`



```

##### 应用：切换全局主题颜色

```jsx
//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ThemeProvider } from 'styled-components';
import { CssApp } from './CssApp';
import {lightTheme }from '../src/style/themBright'
import {defaultTheme} from '../src/style/themDefault'
const root = ReactDOM.createRoot(document.getElementById('root'));
class App extends React.Component {
  constructor() {
    super();
    this.state = {
      isDefault: true,
    }
  }
  changeTheme = () => {
    this.setState((state) => ({
      isDefault: !state.isDefault,
    }));
  }

  render() {
    const theme = this.state.isDefault ? defaultTheme : lightTheme;
    return (
      <ThemeProvider theme={theme}>//使用ThemeProvider传递主题色，后代直接使用props.them的变量
        <CssApp changeTheme={this.changeTheme} />
      </ThemeProvider>
    );
  }
}
root.render(<App />);


//CssApp
import React, { PureComponent } from 'react'
import { Appwrapper,Headerwrapper,Flootwrapper} from './css/style.js'

export class CssApp extends PureComponent {
      changeTheme() {
          this.props.changeTheme()//调函数切换主题
      }
  render() {
    return (
      <>
       <Appwrapper >
      <h3 className='title'>我是标题</h3>
      <hr />
      <Headerwrapper >
        <h3 className='title'>css in js </h3>
        </Headerwrapper>
      <Flootwrapper >
      <p className='text'>免责声明</p>
      <p className='text'>版权声明</p>
      </Flootwrapper>
      </Appwrapper>
      <button onClick={()=>{this.changeTheme()}}>切换主题</button>
      </>
    )
  }
}

//style.js
import styled from 'styled-components'

export const Appwrapper=styled.div`
.title{
   color: ${props=>props.theme.primaryColor};
}
`
export const Headerwrapper=styled.div`
 .title{
    color: ${props=>props.theme.primaryColor};
 }
 .content{
   color: ${props=>props.theme.primaryColor};
    border: 1px solid ${props=>props.theme.primaryColor};
    width: 100px;
    height: 100px;
    line-height: 100px;
    text-align: center;
 }
`
export const Flootwrapper=styled.div`
.text{
   font-size: ${props=>props.theme.smallSize};
   color: ${props=>props.theme.primaryColor};
}
`
```

#### className

使用库： pnpm i classnames

```jsx
动态添加类名，true添加class  
this.state={
        isStatement:true
      }      
<p className={classNames('text',{statement:isStatement})}>免责声明</p>

```

## 状态管理

### Redux

##### 基本使用

使用库：pnpm i redux

```jsx
1.index.js
import {createStore} from 'redux'
import reducer from './reducer.js'
const store=createStore(reducer)//初始化，传入reducer函数
export default store

2.reducer.js
import { CHANGE_NAME } from './constants.js'
const initalState={
    name:'xxm',
    age:19
}
//reducer函数返回state
const reducer=(state=initalState,action)=>{
    switch(action.type){
        case CHANGE_NAME:
            return{...state,name:action.name}
        default:
            return state
    }
}
export default reducer

3.constants.js,定义触发的type
export const CHANGE_NAME='change_name'

4.actionCreators，定义触发的函数
import { CHANGE_NAME } from "./constants.js"
export const changeNameAction=(name)=>{
    return {type:CHANGE_NAME,name}
}

使用：
import store from "./index.js";
import { changeNameAction } from "./actionCreators.js"
//订阅store的变化，改变就调用回调,store.getState()输出state数据
const unsubscribe=store.subscribe(()=>{
    console.log(store.getState());
})
store.dispatch(changeNameAction('zzy'))//调用reducer，修改name
unsubscribe()//取消订阅

```

##### Redux高阶组件

使用库：pnpm i react-redux

```jsx
index.js
1.使用 Provider传递store
import {Provider} from 'react-redux'

root.render(
<Provider store={store}>
<StoreApp />
</Provider>
);

Home.jsx
2.组件通过connect连接
const mapStateToProps=(state)=>{//映射状态传递给组件
return{
  count:state.count,
  name:state.name
}
}
const mapDispatchToProps=(dispatch)=>{//映射方法传递给组件
return{
  toAddCount(num){
    dispatch(addCount(num))
  },
  toSubCount(num){
    dispatch(subCount(num))

  }
}
}
export default connect(mapStateToProps,mapDispatchToProps)(Home)//connect高阶函数，返回一个高阶组件


3.使用
class Home extends PureComponent {
  changeCount(state){
    if(state===1){
      console.log('加一')
     this.props.toAddCount(this.props.count+1)
    }else{
      this.props.toAddCount(this.props.count-1)
      console.log('减一');
    }
  } 
  render() {
    const {count}=this.props
    return (
      <>
      Home:{count}
      <button onClick={()=>{this.changeCount(1)}}>+1</button>
      <button onClick={()=>{this.changeCount(-1)}}>-1</button>
      </>
    )
  }
}
  
```

##### Redux使用中间件派发函数异步请求

使用库：pnpm i redux-thunk

```ts
//store/index.js
import { createStore,applyMiddleware } from "redux"
import {thunk} from 'redux-thunk'//使用中间件
import reducer from "./reducer"
const store=createStore(reducer,applyMiddleware(thunk))
export default store


//actionCreators.js
export const getDate=async()=>{
    function foo(dispatch,getState){
       axios.get('http://loaclhost:80/list').then((res)=>{
        const bannerList=res.data.list
        dispatch(setBanner(bannerList))
       })
    }
    return foo
}
```

##### 打开扩展插件数据显式

```tsx
import { createStore,applyMiddleware,compose } from "redux"
import {thunk} from 'redux-thunk'
import reducer from "./reducer"

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose//开启store显式数据
const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)))
export default store
```

##### 模块化

```jsx
//index.js
使用结合combineReducers多个reducer
import { createStore,combineReducers ,compose} from 'redux';
import countReducer from './count/reducer'
import homeReducer from './home/reducer'
const reducer=combineReducers({//combineReducers实现模块化
    count:countReducer,
    home:homeReducer
})
const store=createStore(reducer)
export default store


//使用：
import React, { PureComponent } from 'react'
import { addCountAction, subCountAction } from './store/count/actionCreators';
import { connect } from 'react-redux';
export class App extends PureComponent {
  changeCount (state){
    if(state===1){
      this.props.toAddCount(1)
    }else{
      this.props.toSubCount(1)
    }
   }
  render() {
    const {count}=this.props
    return (
      <>
       <h3>count:{count}</h3>
       <div>
        <button onClick={()=>{this.changeCount(1)}}>+</button>
        <button onClick={()=>{this.changeCount(0)}}>-</button>
        </div> 
        <hr/>
      <h3>
        home:{store.getState().home.name}
      </h3>
      <button>change</button>
      </>
    )
  }
}
const mapStateToProps=(state)=>{
  return{
    count:state.count.count//多包了一层
  }
}
const mapDispatchToProps=(dispatch)=>{
  return{
    toAddCount(val){
      dispatch(addCountAction(val))
    },
    toSubCount(val){
      dispatch(subCountAction(val))
    }
  }
}
export default connect(mapStateToProps,mapDispatchToProps)( App)
```

### ReduxToolkit

pnpm i @reduxjs/toolkit react-redux

##### 基本使用

```jsx
//index.js
import {configureStore} from '@reduxjs/toolkit'、
import countReducer from './count'
const store=configureStore({
  reducer:{
   counter:countReducer//挂载到reducer
  },
  devTools:true
})
export default store

//countSlice.jsx
import { createSlice } from "@reduxjs/toolkit";
const countSlice=createSlice({
    name:"countSlice",//唯一标识
    initialState:{//初始值
        num:10
    },
    reducers:{
        addNum(state,action){
          state.num+=action.payload
        },
        subNum(state,action){
            state.num-=action.payload
        }
    }
})
export const {addNum,subNum}=countSlice.actions//暴露方法
export default countSlice.reducer
```

##### 异步请求

```jsx
//banner.js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import axios from 'axios'
export const fetchBannerList=createAsyncThunk('banners/fetchBannerList',// 操作的类型，用于标识这个异步操作
    async ()=>{
  const res=await  axios.get("http://localhost:3001/rest/banner")
  //返回结果，action状态变成fulfilled
  return res.data.data
    }
) 

const banner=createSlice({
    name:"banner",
    initialState:{
        bannerList:[]
    },
    reducers:{},
    extraReducers: (builder) => {//通过extraReducers监听fetchBannerList的三种状态
        builder
            .addCase(fetchBannerList.fulfilled, (state, action) => {
                state.bannerList = action.payload;
            })
     }
})
export default banner.reducer

使用
//App.jsx
import React, { PureComponent ,Fragment} from 'react'
import { connect } from 'react-redux'
import { addNum, subNum } from './store/rtk/count'
import { fetchBannerList } from './store/rtk/banner'

export class RtkApp extends PureComponent {
    componentDidMount(){
      this.props.getBannerList()//触发getBannerList
    }
  render() {
    const bannerList=this.props.bannerList
    const num=this.props.num
    return (
      <>
    {bannerList.map((item)=>{
      return (
     <Fragment key={item.id}>
      <img src={`http://localhost:3001${item.url}`} alt={item.name} height="200px" />
     </Fragment>
    )
    })}
      </>
    )
  }
}
const mapStateToProps=(state)=>({
    bannerList:state.banner.bannerList
})
const mapDispatchToProps=(dispatch)=>({
    getBannerList(){
      dispatch(fetchBannerList())//触发fetchBannerList获取数据
    }
})
export default connect(mapStateToProps,mapDispatchToProps)(RtkApp)
```

#### 使用hook操作RTK

useSelector、useDispatch，shallowEqual

```jsx
import React, { memo,useMemo } from 'react'
import { useDispatch, useSelector，shallowEqual } from 'react-redux'
import { addNum } from './store/rtk/count'
const StoreApp = memo((props) => {
    const {count}=useSelector((state)=>({//使用useSelector，传入一个回调返回state
        count:state.counter.num
    }),shallowEqual)//浅层比较，减少渲染，提高性能
    const dispatch=useDispatch()//获取dispatch对象派发事件
    const changeNum=()=>{
        dispatch(addNum(1))
    }
  return (
    <>
    {count}
    <button onClick={changeNum}>dispatch</button>
    </>
  )
})
export default StoreApp
```

## React路由

pnpm i react-router-dom

#### 基础使用

```jsx
import React, { PureComponent } from 'react'
import { Link, Route, Routes } from 'react-router-dom'
import { Home } from './components/Home';
import { Mine } from './components/Mine';
export class RouteApp extends PureComponent {
  render() {
    return (
      <>
      <div>
        <Link to="/home">首页</Link>  {/*使用Link组件进行跳转 */}
        <Link to="/mine">个人中心</Link>
      </div>
        {/*路由配置*/}
    <Routes>
        <Route path='/home' element={<Home/>}/>
        <Route path="/mine" element={<Mine/>} />
    </Routes>
      </>
    )
  }
}
export default RouteApp

//index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import store from './store/rtk/index';
import {Provider} from 'react-redux'
import RouteApp from './RouteApp';
import {BrowserRouter,HashRouter} from 'react-router-dom'
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <BrowserRouter>
    <Provider store={store}>
    <RouteApp />
    </Provider>
    </BrowserRouter>
)
```

#### 路由跳转

###### 1.Link

```jsx
 <Link to="/home">首页</Link> 
 <Link to="/mine">个人中心</Link>
```

###### 2.NavLink

激活状态会自动添加active类

```jsx
传入一个函数，函数接收一个对象，包含isActive属性
1.默认激活会添加上active类名
<NavLink to="/home" style={({isActive})=>({color:isActive? 'pink':''})}>首页</NavLink>
<NavLink to="/mine" style={({isActive})=>({color:isActive? 'pink':''})}>个人中心</NavLink>

2.自定义类名
 <NavLink to="/home" className={({isActive})=>isActive?"link-active":''}>首页</NavLink>
 <NavLink to="/mine" className={({isActive})=>isActive?"link-active":''}>个人中心</NavLink>
```

###### 3.Navigate重定向

```jsx
//重定向
<Route path='/' element={<Navigate to="/home"/>}/>
<Route path='/home' element={<Home/>}/>
<Route path="/mine" element={<Mine/>} />
```

###### 4.useNavigate()

```jsx
1.类组件，借助HOC高阶组件使用hook
//hoc
import React from 'react';
import { useNavigate } from 'react-router-dom';

function withRouter(NewComponent) {
    return function(props) {
        const navigate = useNavigate();
        const routerLink={navigate}
        return <NewComponent {...props} routerLink={routerLink} />;
    };
}
export default withRouter;

//类组件
 class Home extends PureComponent {
  toMinePage=()=>{
    this.props.routerLink.navigate('/mine')
    };
    render() {
        console.log(this.props); 
        return (
            <>
                Home
                <button onClick={()=>{this.toMinePage()}}>toMime</button>
                <hr />
                <Outlet />
            </>
        )
    }
}

2.函数组件
export default withRouter(Home);
const navigate=useNavigate()
const toMine=()=>{
    navigate('/mine'，replace)
}
```

#### 路由传参

```jsx
1.动态路由传参
 <Route path='/home/details/:id' element={<Details/>}></Route>
接收参数：通过useParams
const params=useParams()获取id

2.查询字符串
<NavLink to="/home/details?id=2" className={({isActive})=>isActive?"link-active":''}>详情</NavLink>
接收参数通过useSearchParams
const [searchParams]=useSearchParams()
const query=Object.fromEntries(searchParams)
```

#### 路由嵌套

```jsx
<Routes>
        <Route path='/' element={<Navigate to="/home"/>}/>
        <Route path='/home' element={<Home/>}>
         <Route path='/home' element={<Navigate to='/home/list'/>}/>
         <Route path='/home/list' element={<List/>}/>
        </Route>
        <Route path="/mine" element={<Mine/>} />
</Routes>

//Home.jsx
import React, { PureComponent } from 'react'
import { Outlet } from 'react-router-dom'

export class Home extends PureComponent {
  render() {
    return (
      <>
      Home
      {/* 路由容器,放置子路由*/}
      <Outlet></Outlet>  
      </>
    )
  }
}

export default Home
```

#### 路由配置表

```jsx
router/index.js
import React, { lazy } from "react";
import { createBrowserRouter, Navigate } from "react-router-dom";
const List = lazy(() => import('../components/List')) //懒加载
const Mine = lazy(() => import('../components/Mine')) //懒加载
const Home=lazy(()=>impost('../components/Home')) //懒加载
const router = createBrowserRouter([
  {
    path: '/',
    element: <Navigate to="/home/list" replace />, // 重定向到 /home/list
  },
  {
    path: '/home',
    element: <Home />,
    children: [
      {
        path: '', // 空路径表示是默认子路由
        element: <List />, // 默认显示 List 组件
        index: true, // 设置为默认子路由
      },
      {
        path: 'list', // 子路由的路径
        element: <List />, // 显示 List 组件
      },
    ],
  },
  {
    path: '/mine',
    element: <Mine />,
  },
   {
       path：'*',
       element:<NotFound></NotFound>
    } 
]);
export default router;


//index.js
root.render(
    <RouterProvider router={router}>
    <App></App>
    </RouterProvider>
)
```
